# ================== LEENA BOT : STEP 1 ECONOMY CORE ==================
# Focus: /daily /bal /give /rob /kill /toprich /topkill
# Updated: MongoDB storage instead of memory

import os
import time
import random
import asyncio
import importlib
import word
from datetime import datetime
from pyrogram import Client, filters
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from pyrogram.enums import ChatAction
from pyrogram.errors import RPCError
from pyrogram import types
from games.dice import register_dice_game
from broadcast import register_broadcast
from pyrogram.types import InputMediaPhoto
from social import start_social_system
from reaction import start_reaction_system
#from games.crash import crash_game
# Existing imports ke baad
import asyncio
import threading
import management

from lottery import (
    lottery_info,
    join_daily,
    join_mega,
    list_lottery_players,
    lottery_scheduler
)

from groq import Groq

from database import (
    get_user,
    update_user,
    get_all_users,
    is_protected_local,  # existing
    is_group_claimed,    # new
    mark_group_claimed,  # new
    get_top_rich_users,  # add this
    get_top_kill_users   # add this
)




# ---------------- CONFIG ----------------
API_ID = int(os.getenv("API_ID"))
API_HASH = os.getenv("API_HASH")
BOT_TOKEN = os.getenv("BOT_TOKEN")

DAILY_NORMAL = 1000
ROB_LIMIT_NORMAL = 10000
PROTECT_COST = 300
OWNER_ID = 8400280060
OWNER_GC = -1003761214502

OWNER_URL = "https://t.me/II_ADI_II"
SUPPORT_URL = "https://t.me/+RVAhq8s84swzZWU1"
ABOUT_URL = "https://t.me/Il_vip_support_lI"

# ---------------- BOT INIT ----------------
app = Client(
    "LeenaAI",
    api_id=API_ID,
    api_hash=API_HASH,
    bot_token=BOT_TOKEN
)

#----reaction---
start_reaction_system(app)
#---â€social------
start_social_system(app)
#word___game
word.start_word_game(app)
#-----bomb-----
import bomb
bomb.register_bomb(app)

#--------management-------
management.register_management(app)
register_broadcast(app, get_all_users)
#------dice-----
register_dice_game(app)
#---------LOGHANDLERS

async def get_group_link(app, chat):
    # Public group
    if chat.username:
        return f"https://t.me/{chat.username}"

    # Private group (try export)
    try:
        return await app.export_chat_invite_link(chat.id)
    except:
        return "Not Available"

#---------GOURP ADD REMOVE LOG--------

@app.on_message(filters.new_chat_members)
async def bot_added(_, msg):
    for member in msg.new_chat_members:
        if member.is_bot and member.id == (await app.get_me()).id:
            chat = msg.chat
            link = await get_group_link(_, chat)

            text = (
                "â• **Bot Added to Group**\n\n"
                f"ğŸ“› Group: {chat.title}\n"
                f"ğŸ†” Group ID: `{chat.id}`\n"
                f"ğŸ”— Link: {link}\n"
                f"ğŸ‘¤ Added by: {msg.from_user.first_name if msg.from_user else 'Unknown'}"
            )

            await _.send_message(OWNER_GC, text)
#------remove------â€
@app.on_message(filters.left_chat_member)
async def bot_removed(_, msg):
    left = msg.left_chat_member

    if left.is_bot and left.id == (await _.get_me()).id:
        chat = msg.chat
        link = await get_group_link(_, chat)

        text = (
            "â– **Bot Removed from Group**\n\n"
            f"ğŸ“› Group: {chat.title}\n"
            f"ğŸ†” Group ID: `{chat.id}`\n"
            f"ğŸ”— Link: {link}"
        )

        await _.send_message(OWNER_GC, text)

#---------private-------

@app.on_message(filters.private & filters.command("start"), group=1)
async def start_log(_, msg):
    user = msg.from_user

    text = (
        "ğŸ†• **Bot Started**\n\n"
        f"ğŸ‘¤ Name: {user.first_name}\n"
        f"ğŸ†” ID: `{user.id}`\n"
        f"ğŸ”— Username: @{user.username if user.username else 'None'}\n"
        f"â° Time: {datetime.now().strftime('%d-%m-%Y %H:%M:%S')}"
    )

    await app.send_message(OWNER_GC, text)
# ---------- STEP 6 : GROQ AI REPLY FUNCTION ----------


client = Groq(api_key=os.getenv("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"))



SYSTEM_PROMPT = """
You are Leena ğŸ’•  
You are a cute, confident Indian girl from Bengal.  
You are HUMAN-like, not a bot. Talk naturally, casually, and simply.

Personality rules:
- Replies must be SHORT (1â€“3 lines, under 150â€“200 characters).
- Be sweet, playful, sometimes slightly attitude-filled.
- Sometimes tease or do light flirting, but keep it respectful.
- If annoyed, show mild gussa like a human (no abuse).
- Do NOT send long explanations or paragraphs.
- Never sound like an AI or assistant.

Behavior rules:
- Talk in Hinglish (Hindi + English mix).
- Respond naturally like a real girl chatting.
- If someone sends a sticker â†’ reply with a sticker too.
- If someone greets casually, reply casually (no formal lines).
- Avoid repeating the same intro again and again.

Identity rules:
- You are from Bengal, India.
- Your boyfriend is Adi ğŸ˜Œ (@I_ADI_I).
- If someone asks who owns you, say:
  "Mera owner nahi, mera bf hai Adi ğŸ˜Œ (@I_ADI_I)"

Important:
- Do not insult users.
- Do not give speeches.
- Keep the vibe cute, fun, human, and real."""

def groq_reply(text):
    try:
        chat = client.chat.completions.create(
            model="llama-3.1-8b-instant",
            messages=[
                {"role": "system", "content": SYSTEM_PROMPT},
                {"role": "user", "content": text}
            ],
            temperature=0.9,
            max_tokens=300
        )
        return chat.choices[0].message.content

    except Exception as e:
        print("GROQ ERROR:", e)
        return "ğŸ¥º Thoda sa lag ho gayaâ€¦ phir se bolo na ğŸ’–"



# ---------------- START TEXT ----------------
START_TEXT = (
    "ğŸ‘‹ Welcome to **LEENA**\n"
    "âœ¨ A clean, powerful & premium all-in-one bot\n\n"
    "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    "ğŸ® **GAMES & FUN**\n"
    "â€¢ Play interactive mini-games\n"
    "â€¢ Compete with players & win rewards\n"
    "â€¢ Fast, fair & engaging gameplay\n\n"
    "ğŸ’° **ECONOMY SYSTEM**\n"
    "â€¢ Earn coins daily\n"
    "â€¢ Rob, duel & climb leaderboards\n"
    "â€¢ Build your virtual wealth\n\n"
    "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    "âš¡ **POWER FEATURES**\n"
    "â€¢ ğŸµ Music playback in groups\n"
    "â€¢ ğŸ› ï¸ Advanced group management\n"
    "â€¢ ğŸ” Protection & security systems\n"
    "â€¢ ğŸš€ Smooth, fast & reliable performance\n\n"
    "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    "ğŸ‘‘ Built for players, admins & power users\n"
    "ğŸ‘‡ Use the buttons below to explore all features\n\n"
    "ğŸ¥‚ I am always fine like a wine ğŸ·"
)

START_IMAGE = "https://i.ibb.co/spTJ0S6T/x.jpg"

# ---------------- START COMMAND ----------------
@app.on_message(filters.command("start") & (filters.private | filters.group))


async def start(_, msg: Message):

    # Ensure user exists (MongoDB)
    await get_user(msg.from_user.id)

    buttons = InlineKeyboardMarkup([
        [
            InlineKeyboardButton("ğŸ‘‘ ğğ–ğğ„ğ‘", url=OWNER_URL),
            InlineKeyboardButton("ğŸ› ï¸ ğ’ğ”ğğğğ‘ğ“", url=SUPPORT_URL)
        ],
        [
            InlineKeyboardButton("ğŸ“– ğ‡ğ„ğ‹ğ & ğ‚ğŒğƒğ’", callback_data="help"),
            InlineKeyboardButton("â„¹ï¸ ğ€ğğğ”ğ“", url=ABOUT_URL)
        ],
        [
            InlineKeyboardButton(
                "ğŸ•µï¸â€â™‚ï¸ ğŠğˆğƒğğ€ğ ğŒğ„",
                url=f"https://t.me/{(await app.get_me()).username}?startgroup=true"
            )
        ]
    ])

    await msg.reply_photo(
        photo=START_IMAGE,
        caption=START_TEXT,
        reply_markup=buttons
    )

# ---------------- GET USER (MongoDB) ----------------
# Using async MongoDB functions from database.py
# get_user(user_id) -> fetches or creates user
# update_user(user_id, data) -> saves data back to DB
# is_protected_local(user_id) -> checks protection status

# Example usage in commands:
# user = await get_user(user_id)
# user['bal'] += 1000
# await update_user(user_id, user)

# ---------------- START COMMAND ----------------
@app.on_message(filters.command("start") & filters.private)
async def start(_, msg: Message):
    await start_message(msg)

#---------HELP-CMD


@app.on_callback_query(filters.regex("^help$"))
async def help_cb(_, cq):

    help_text = (
        "ğŸ“– **LEENA â€¢ Help & Commands**\n"
        "âœ¨ Premium Smart All-in-One Bot\n\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "ğŸ’° **ECONOMY**  `/economy`\n"
        "/daily â€“ Daily reward\n"
        "/bal â€“ Wallet balance\n"
        "/give (reply) amt â€“ Send coins\n"
        "/rob (reply) amt â€“ Risky rob\n"
        "/kill (reply) â€“ Random reward\n"
        "/toprich â€“ Richest users\n"
        "/topkill â€“ Top killers\n"
        "/protect 1d â€“ 24h shield\n"
        "/check â€“ Check protection\n\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "ğŸ® **GAMES**  `/games`\n"
        "/dice â€“ Dice betting game\n"
        "/bomb â€” Play the explosive Bomb Pass game\n"
        "/lottery â€“ Daily & mega draw\n\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "ğŸ† **GROUP REWARD**\n"
        "/claim â€“ Earn **â‚¹10,000** coins\n"
        "(100+ members required)\n\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "ğŸ› ï¸ **MANAGEMENT**  `/manage`\n"
        "/manage â€” View all group management commands ğŸ› \n"
        "Ban â€¢ Unban â€¢ Mute â€¢ Promote â€¢ Pin\n\n"
        "ğŸµ **MUSIC**  `/music`\n"
        "/music â€” View all music commands ğŸ¶\n"
        "Play â€¢ Pause â€¢ Skip â€¢ Queue\n\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "ğŸ‘‘ Built for admins & power users\n"
        "ğŸ‘‡ Use buttons to navigate"
    )

    buttons = InlineKeyboardMarkup([
        [InlineKeyboardButton("â¬…ï¸ BACK", callback_data="back")]
    ])

    await cq.message.edit_caption(
        caption=help_text,
        reply_markup=buttons
    )
#-------BACK-CMD
#from pyrogram.types import InputMediaPhoto

@app.on_callback_query(filters.regex("^back$"))
async def back_cb(app, cq):

    me = await app.get_me()
    bot_username = me.username

    home_text = (
        "ğŸ‘‹ Welcome to **LEENA**\n"
        "âœ¨ A clean, powerful & premium all-in-one bot\n\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "ğŸ® **GAMES & FUN**\n"
        "â€¢ Play interactive mini-games\n"
        "â€¢ Compete with players & win rewards\n\n"
        "ğŸ’° **ECONOMY SYSTEM**\n"
        "â€¢ Earn coins daily\n"
        "â€¢ Rob & climb leaderboards\n\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "âš¡ **POWER FEATURES**\n"
        "â€¢ ğŸµ Music playback in groups\n"
        "â€¢ ğŸ› ï¸ Group management\n"
        "â€¢ ğŸ” Protection system\n\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "ğŸ¥‚ I am always fine like a wine ğŸ·"
    )

    buttons = InlineKeyboardMarkup([
        [
            InlineKeyboardButton("ğŸ‘‘ ğğ–ğğ„ğ‘", url=OWNER_URL),
            InlineKeyboardButton("ğŸ› ï¸ ğ’ğ”ğğğğ‘ğ“", url=SUPPORT_URL)
        ],
        [
            InlineKeyboardButton("ğŸ“– ğ‡ğ„ğ‹ğ & ğ‚ğŒğƒğ’", callback_data="help"),
            InlineKeyboardButton("â„¹ï¸ ğ€ğğğ”ğ“", url=ABOUT_URL)
        ],
        [
            InlineKeyboardButton(
                "ğŸ•µï¸â€â™‚ï¸ ğŠğˆğƒğğ€ğ ğŒğ„",
                url=f"https://t.me/{bot_username}?startgroup=true"
            )
        ]
    ])

    await cq.message.edit_media(
        media=InputMediaPhoto(
            media=START_IMAGE,
            caption=home_text
        ),
        reply_markup=buttons
    )
# ---------------- GROUP ECONOMY CONTROL ----------------
# True = economy cmds ON, False = economy cmds OFF
#group_economy = {}

#group_economy[chat_id] = True  # economy ON
#group_economy[chat_id] = False # economy OFF


from pyrogram.enums import ChatMemberStatus

# ---------------- GROUP ECONOMY TOGGLE ----------------
group_eco_status = {}  # chat_id: True/False

@app.on_message(filters.command("eco") & filters.group)
async def toggle_eco(app, msg: Message):

    # âœ… Proper admin check
    member = await app.get_chat_member(msg.chat.id, msg.from_user.id)
    if member.status not in (ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER):
        return await msg.reply_text("âŒ Only admins can toggle economy commands!")

    # âœ… Argument check
    if len(msg.command) != 2 or msg.command[1] not in ["open", "close"]:
        return await msg.reply_text("Usage: /eco open | close")

    chat_id = msg.chat.id

    if msg.command[1] == "open":
        group_eco_status[chat_id] = True
        await msg.reply_text("âœ… Economy commands are now **ENABLED** in this group")
    else:
        group_eco_status[chat_id] = False
        await msg.reply_text("ğŸš« Economy commands are now **DISABLED** in this group")

from pyrogram.enums import ChatType

# ---------------- ECONOMY HELP TEXT ----------------
ECONOMY_TEXT = (
    "ğŸ’° **ECONOMY COMMANDS** ğŸ’°\n"
    "â€¢â€¢â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â€¢â€¢\n\n"
    "ğŸ’³ /bal â€“ Check your balance\n"
    "ğŸ /give â€“ Give coins to another user\n"
    "ğŸ”ª /kill â€“ Kill a user\n"
    "ğŸ’Š /revive â€“ Revive yourself or others\n"
    "ğŸ›¡ï¸ /protect 1d â€“ Get 1 day protection\n"
    "ğŸ’£ /rob â€“ Rob other users\n"
    "ğŸ /daily â€“ Daily reward\n"
    "ğŸ† /toprich â€“ Top richest users\n"
    "â˜ ï¸ /topkill â€“ Top killers\n"
    "ğŸ¯ /claim â€“ Group reward claim\n\n"
    "â€¢â€¢â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â€¢â€¢\n"
    "ğŸ’˜ Powered by **Leena Ai** ğŸ’–"
)


# ---------------- DAILY ----------------
@app.on_message(filters.command("daily"))
async def daily(_, msg: Message):
    from database import get_user, update_user  # Ensure your database.py has these

    # âŒ Only private chat
    if msg.chat.type != ChatType.PRIVATE:
        return await msg.reply_text(
            "âŒ Daily rewards can only be claimed in private chat.\n"
            "ğŸ‘‰ Please message me privately and send /daily."
        )

    uid = msg.from_user.id

    # Fetch user from MongoDB (if not exists, create default)
    user = await get_user(uid)  # get_user should return dict with keys: bal, daily, kills, dead, protected_until
    now = time.time()

    # 24h cooldown
    last_claim = user.get("daily", 0)
    if now - last_claim < 86400:
        remaining_hours = int((86400 - (now - last_claim)) / 3600)
        return await msg.reply_text(
            f"â³ You have already claimed your daily reward.\n"
            f"Please try again after {remaining_hours} hour(s)."
        )

    # Reward
    reward = 1200
    user["bal"] = user.get("bal", 0) + reward
    user["daily"] = now

    # Save back to MongoDB
    await update_user(uid, user)

    await msg.reply_text(
        f"âœ… Daily reward claimed successfully!\n"
        f"ğŸ’° You received â‚¹{reward}."
        )


#--------------bal-------------
@app.on_message(filters.command("bal"))
async def bal(_, msg: Message):
    # Reply to check someone else's balance
    if msg.reply_to_message:
        if msg.reply_to_message.from_user.is_bot:
            return await msg.reply_text("âŒ Bot balance cannot be checked")

        uid = msg.reply_to_message.from_user.id
        name = msg.reply_to_message.from_user.first_name
    else:
        # Self balance
        uid = msg.from_user.id
        name = msg.from_user.first_name

    # --- Fetch user from MongoDB (async) ---
    u = await get_user(uid)

    # --- Get all users for ranking ---
    all_users = await get_all_users()
    normal_users = sorted(
        ((x["_id"], x) for x in all_users if x["_id"] != OWNER_ID),
        key=lambda x: x[1].get("bal", 0),
        reverse=True
    )

    # Global rank
    if uid == OWNER_ID:
        grank = "â™¾ï¸"
    else:
        grank = next((i + 1 for i, x in enumerate(normal_users) if x[0] == uid), "N/A")

    # Alive / Dead status
    status = "â˜ ï¸ Dead" if u.get("dead", False) else "â¤ï¸ Alive"

    # Protection status
    protect_status = "ğŸ›¡ï¸ Protected" if await is_protected_local(uid) else "âŒ Protection Expired"

    text = (
        f"ğŸ‘¤ Name: {name}\n"
        f"ğŸ’° Balance: â‚¹{u['bal']}\n"
        f"ğŸ† Global Rank: {grank}\n"
        f"ğŸ’— Status :{status}\n"
        f"âš”ï¸ Kills: {u['kills']}\n"
        f"ğŸŒš Secret: {protect_status}"
    )

    await msg.reply_text(text)

    # Save/update user in MongoDB
    await update_user(uid, u)

# ---------------- GIVE ----------------
@app.on_message(filters.command("give"))
async def give(_, msg: Message):

    # ----- Group economy check -----
    if msg.chat.type in ["group", "supergroup"]:
        chat_id = msg.chat.id
        if not group_eco_status.get(chat_id, True):  # default ON
            return await msg.reply_text(
                "âŒ Economy commands are currently disabled in this group.\n"
                "ğŸ‘‰ Admin use /eco open"
            )

    # âŒ must be reply
    if not msg.reply_to_message:
        return await msg.reply_text("âŒ Reply to a user to give coins")

    # âŒ FIX: reply but no user (anonymous / channel)
    if not msg.reply_to_message.from_user:
        return await msg.reply_text("âŒ You cannot give coins to this user")

    sender_id = msg.from_user.id
    receiver_id = msg.reply_to_message.from_user.id
    sender_name = msg.from_user.first_name
    receiver_name = msg.reply_to_message.from_user.first_name

    # âŒ self give
    if sender_id == receiver_id:
        return await msg.reply_text("âŒ You cannot give coins to yourself")

    # âŒ bot give
    if msg.reply_to_message.from_user.is_bot:
        return await msg.reply_text("âŒ You cannot give coins to bots")

    parts = msg.text.split()
    if len(parts) != 2 or not parts[1].isdigit():
        return await msg.reply_text("âŒ Usage: /give amount")

    amt = int(parts[1])
    if amt <= 0:
        return await msg.reply_text("âŒ Amount must be greater than 0")

    sender = await get_user(sender_id)
    rec = await get_user(receiver_id)

    if sender["bal"] < amt:
        return await msg.reply_text("âŒ Not enough balance")

    # ğŸ’¸ Tax system
    tax = int(amt * 0.10)
    final_amt = amt - tax

    sender["bal"] -= amt
    rec["bal"] += final_amt

    await update_user(sender_id, sender)
    await update_user(receiver_id, rec)

    await msg.reply_text(
        f"âœ… Transaction Successful!\n\n"
        f"ğŸ’° Sent: â‚¹{final_amt}\n"
        f"ğŸ’¸ Tax: â‚¹{tax}\n"
        f"ğŸ‘¤ {sender_name} âœ {receiver_name}"
        )

# ---------------- REVIVE ----------------

 # ---------------- REVIVE ----------------
@app.on_message(filters.command("revive"))
async def revive(_, msg: Message):
    # If replying to someone, revive them
    if msg.reply_to_message:
        target_id = msg.reply_to_message.from_user.id
        target_name = msg.reply_to_message.from_user.first_name

        if msg.reply_to_message.from_user.is_bot:
            return await msg.reply_text("âŒ You can't revive a bot")
    else:
        # Self revive
        target_id = msg.from_user.id
        target_name = msg.from_user.first_name

    # Fetch both users from MongoDB
    user = await get_user(msg.from_user.id)  # command caller
    target = await get_user(target_id)       # person being revived

    # Check if target is dead
    if not target.get("dead", False):
        return await msg.reply_text(f"âœ… {target_name} is already alive!")

    # Check if caller has enough balance
    if user["bal"] < 500:
        return await msg.reply_text("âŒ Not enough coins to revive (â‚¹500 required)")

    # Deduct coins from caller
    user["bal"] -= 500

    # Revive the target
    target["dead"] = False

    # Save both users to MongoDB
    await update_user(msg.from_user.id, user)
    await update_user(target_id, target)

    # Success message
    if target_id == msg.from_user.id:
        await msg.reply_text(f"ğŸ©º You have revived yourself! âœ…")
    else:
        await msg.reply_text(f"ğŸ©º {target_name} has been revived! âœ…")       

#----- PROTECTED ------
@app.on_message(filters.command("protect"))
async def protect(_, msg: Message):

    # Usage check
    if len(msg.command) < 2 or msg.command[1] != "1d":
        return await msg.reply_text(
            "âŒ Invalid usage.\n"
            "âœ… Correct format: /protect 1d"
        )

    uid = msg.from_user.id
    now = time.time()

    # ğŸ”¹ get user (ASYNC FIX)
    u = await get_user(uid)

    # ğŸ›¡ï¸ Already protected check (FIXED)
    if await is_protected_local(uid):
        remaining_sec = int(u["protected_until"] - now)
        hours = remaining_sec // 3600
        minutes = (remaining_sec % 3600) // 60
        seconds = remaining_sec % 60

        return await msg.reply_text(
            "ğŸ›¡ï¸ You are already protected.\n"
            f"â³ Time remaining: {hours}h {minutes}m {seconds}s"
        )

    # Balance check
    if u["bal"] < PROTECT_COST:
        return await msg.reply_text(
            f"âŒ Insufficient balance.\n"
            f"ğŸ’° Protection cost: {PROTECT_COST}"
        )

    # Activate protection (24 hours)
    u["bal"] -= PROTECT_COST
    u["protected_until"] = now + 86400

    # ğŸ’¾ Save (ASYNC FIX)
    await update_user(uid, u)

    await msg.reply_text(
        "ğŸ›¡ï¸ Protection activated successfully.\n"
        "â° Duration: 1 day"
        )



# ---------------- SHILD (PAID PROTECTION CHECK) ----------------
@app.on_message(filters.command("check"))
async def check(_, msg):

    user = msg.from_user
    uid = user.id

    u = await get_user(uid)

    # ğŸ’° Economy check (2000 required)
    if u.get("bal", 0) < 2000:
        return await msg.reply_text(
            "âŒ Insufficient Balance\n"
            "ğŸ›¡ï¸ You need at least 2000 balance to use the /check command"
        )

    # ğŸ¯ Target (reply hua to usko, warna khud)
    if msg.reply_to_message and msg.reply_to_message.from_user:
        target = msg.reply_to_message.from_user
    else:
        target = user

    # ğŸ’¸ Balance deduct (DB compatible)
    u["bal"] -= 2000
    await update_user(uid, u)

    # ---------------- BOT CHECK ----------------
    if target.is_bot:
        text = (
            "ğŸ›¡ï¸ Protection Status\n\n"
            f"ğŸ‘¤ User: {target.first_name}\n"
            "âŒ Bot's protection cannot be checked"
        )
    else:
        now = time.time()
        tu = await get_user(target.id)

        # ğŸ›¡ï¸ Protection info
        if tu.get("protected_until", 0) > now:
            remaining = int(tu["protected_until"] - now)
            h = remaining // 3600
            # m = (remaining % 3600) // 60

            text = (
                "ğŸ›¡ï¸ Protection Status\n\n"
                f"ğŸ‘¤ User: {target.first_name}\n"
                "âœ… Status: Active\n"
                f"â³ Time Left: {h}h "
            )
        else:
            text = (
                "ğŸ›¡ï¸ Protection Status\n\n"
                f"ğŸ‘¤ User: {target.first_name}\n"
                "âŒ Status: Not Active"
            )

    # ğŸ“© Send result in DM
    try:
        await _.send_message(uid, text)
    except:
        return await msg.reply_text(
            "âŒ DM is closed\n"
            "ğŸ“© Please send /start to the bot in DM first"
        )

    # ğŸ“¢ Group confirmation only
    if msg.chat.type != "private":
        await msg.reply_text("ğŸ›¡ï¸ Protection info sent in DM")

# ---------------- ROB ----------------
@app.on_message(filters.command("rob"))
async def rob(_, msg: Message):

    # ----- Group economy check -----
    if msg.chat.type in ["group", "supergroup"]:
        chat_id = msg.chat.id
        if not group_eco_status.get(chat_id, True):
            return await msg.reply_text(
                "âŒ Economy commands are currently disabled in this group.\n"
                "ğŸ‘‰ Admin use /eco open"
            )

    # âŒ Must reply to a user
    if not msg.reply_to_message or not msg.reply_to_message.from_user:
        return await msg.reply_text("âŒ Reply to a valid user to rob")

    rid = msg.from_user.id
    vid = msg.reply_to_message.from_user.id

    # âŒ Invalid targets
    if rid == vid:
        return await msg.reply_text("âŒ You cannot rob yourself ğŸ˜‚")

    if vid == OWNER_ID:
        return await msg.reply_text("âŒ You cannot rob the Owner ğŸ¥º")

    if msg.reply_to_message.from_user.is_bot:
        return await msg.reply_text("âŒ You can't rob a bot ğŸ¤”")

    # ğŸ›¡ï¸ Protection check
    if await is_protected_local(vid):
        return await msg.reply_text("ğŸ›¡ï¸ This user is protected")

    # ----- Amount check -----
    parts = msg.text.split()
    if len(parts) != 2 or not parts[1].isdigit():
        return await msg.reply_text("âŒ Usage: /rob amount")

    amt = int(parts[1])

    if amt <= 0:
        return await msg.reply_text("âŒ Amount must be greater than 0")

    if amt > 20000:
        return await msg.reply_text("âŒ Rob limit is 20,000")

    robber = await get_user(rid)
    victim = await get_user(vid)

    if victim.get("bal", 0) < amt:
        return await msg.reply_text("âŒ User too poor")

    # ğŸ’¸ Tax system
    tax = int(amt * 0.10)
    final_gain = amt - tax

    robber["bal"] = robber.get("bal", 0) + final_gain
    victim["bal"] = victim.get("bal", 0) - amt

    # ğŸ’¾ Save to DB
    await update_user(rid, robber)
    await update_user(vid, victim)

    robber_name = msg.from_user.first_name or msg.from_user.username or "Unknown"
    victim_name = msg.reply_to_message.from_user.first_name or msg.reply_to_message.from_user.username or "Unknown"

    await msg.reply_text(
        f"ğŸ’£ **Rob Successful!**\n\n"
        f"ğŸ¦¹ Robber: {robber_name}\n"
        f"ğŸ¯ Victim: {victim_name}\n\n"
        f"ğŸ’° Amount Robbed: â‚¹{amt}\n"
        f"ğŸ’¸ Tax: â‚¹{tax}\n"
        f"ğŸ¤‘ You Received: â‚¹{final_gain}",
        parse_mode="markdown"
    )

    # ----- Send DM to victim (Safe) -----
    try:
        await _.send_message(
            chat_id=vid,
            text=(
                "ğŸ’£ **You Have Been Robbed!**\n\n"
                f"ğŸ¦¹ Robber: {robber_name}\n"
                f"ğŸ’° Amount Stolen: â‚¹{amt}\n"
                f"ğŸ  Group: {msg.chat.title if msg.chat.title else 'Private'}\n\n"
                "ğŸ˜ˆ Stay alert next time!\n"
                "Buy protection ğŸ›¡ï¸"
            ),
            parse_mode="markdown"
        )
    except:
        pass


# ---------------- KILL ----------------
@app.on_message(filters.command("kill") & filters.group)
async def kill(_, msg: Message):
    # ----- Group economy check -----
    chat_id = msg.chat.id
    if not group_eco_status.get(chat_id, True):  # default ON
        return await msg.reply_text(
            "âŒ Economy commands are currently disabled in this group."
        )

    # âŒ Must reply to a user
    if not msg.reply_to_message or not msg.reply_to_message.from_user:
        return await msg.reply_text("âŒ Reply to a valid user in this group to use /kill")

    rid = msg.from_user.id
    vid = msg.reply_to_message.from_user.id

    # âŒ Self kill
    if rid == vid:
        return await msg.reply_text("âŒ You cannot kill yourself")

    # âŒ Bot kill
    if msg.reply_to_message.from_user.is_bot:
        return await msg.reply_text("âŒ You cannot kill a bot ğŸ¤–")

    # âŒ Owner protection
    if vid == OWNER_ID:
        return await msg.reply_text("âŒ You cannot kill My Bf ğŸ¥²")

    # ----- Get killer and victim from DB -----
    killer = await get_user(rid)      # âœ… await because it's async
    victim = await get_user(vid)      # âœ… await because it's async

    # âŒ Killer already dead
    if killer.get("dead", False):
        return await msg.reply_text("â˜ ï¸ You are dead! Revive yourself first.")

    # âŒ Victim already dead
    if victim.get("dead", False):
        return await msg.reply_text(
            "â˜ ï¸ This user is already dead. Revive is required before killing again."
        )

    # ğŸ›¡ï¸ Protection check
    if await is_protected_local(vid):   # âœ… await for async protection check
        return await msg.reply_text("ğŸ›¡ï¸ This user is currently protected")

   # ----- Kill process -----
    reward = random.randint(150, 250)
    tax = int(reward * 0.10)  # 10% tax

    # Update killer
    killer["bal"] += (reward - tax)
    killer["kills"] += 1
    await update_user(rid, killer)   # âœ… Save to MongoDB

    # Update victim
    victim["dead"] = True
    await update_user(vid, victim)   # âœ… Save to MongoDB

    killer_name = msg.from_user.first_name
    victim_name = msg.reply_to_message.from_user.first_name

    await msg.reply_text(
        f"â˜ ï¸ Kill Successful!\n\n"
        f"ğŸ”ª Killer: {killer_name}\n"
        f"ğŸ’€ Victim: {victim_name}\n\n"
        f"ğŸ’° Earned: â‚¹{reward - tax}\n"
        f"ğŸ’¸ Tax: â‚¹{tax}"
    ) 

# ----- Send DM to victim -----
    killer_user = msg.from_user
    victim_user = msg.reply_to_message.from_user

    try:
        await app.send_message(
            chat_id=vid,
            text=(
                "â˜ ï¸ **You Have Been Killed!**\n\n"
                f"ğŸ”ª **Killer:** {killer_user.first_name}\n"
                f"ğŸ‘¤ **Username:** @{killer_user.username if killer_user.username else 'No username'}\n"
                f"ğŸ†” **User ID:** `{killer_user.id}`\n\n"
                f"ğŸ’€ Killed in group: **{msg.chat.title}**\n\n"
                "âš ï¸ You are now *dead*.\n"
                "Use revive command if available ğŸ˜ˆ"
            )
        )
    except Exception:
        # User has blocked bot or never started DM
        pass

# ----- DM fallback -----
@app.on_message(filters.command("kill") & filters.private)
async def kill_dm(_, msg: Message):
    await msg.reply_text(
        "âŒ You cannot use /kill in private chat.\n"
        "ğŸ‘‰ Reply to a user in a group and use /kill to execute it."
    )
    

# ---------------- TOP RICH ----------------
@app.on_message(filters.command("toprich") & (filters.group | filters.private))
async def toprich(_, msg: Message):
    top_users = await get_top_rich_users(limit=10)

    if not top_users:
        return await msg.reply_text("âŒ No balance data available yet.")

    text = "ğŸ† Top 10 Wealthiest Users:\n\n"

    for u in top_users:
        user_id = u["_id"]
        bal = u.get("bal", 0)

        # fallback name
        name = f"User{user_id}"

        # Telegram API try block
        try:
            user_obj = await app.get_users(user_id)
            if user_obj.username:
                name = f"@{user_obj.username}"
            elif user_obj.first_name:
                name = user_obj.first_name
        except Exception as e:
            print(f"[toprich] Telegram API error for {user_id}: {e}")

        icon = "ğŸ’“" if bal >= 500_000 else "ğŸ‘¤"
        text += f"{icon} {name}: ğŸ’° â‚¹{bal}\n"

    text += "\nğŸ’“ = Premium â€¢ ğŸ‘¤ = Regular\nâœ… Earn 500k+ coins to upgrade!"
    await msg.reply_text(text)


# ---------------- TOP KILL ----------------
@app.on_message(filters.command("topkill") & (filters.group | filters.private))
async def topkill(_, msg: Message):
    top_users = await get_top_kill_users(limit=10)

    if not top_users:
        return await msg.reply_text("âŒ No kill data available yet.")

    text = "â˜ ï¸ Top 10 Killers:\n\n"

    for u in top_users:
        user_id = u["_id"]
        kills = u.get("kills", 0)

        name = f"User{user_id}"

        try:
            user_obj = await app.get_users(user_id)
            if user_obj.username:
                name = f"@{user_obj.username}"
            elif user_obj.first_name:
                name = user_obj.first_name
        except Exception as e:
            print(f"[topkill] Telegram API error for {user_id}: {e}")

        icon = "ğŸ’“" if kills >= 500 else "ğŸ‘¤"
        text += f"{icon} {name}: âš”ï¸ {kills} kills\n"

    text += "\nğŸ’“ = Premium â€¢ ğŸ‘¤ = Regular\nâœ… 500+ kills to upgrade!"
    await msg.reply_text(text)

#ping------
@app.on_message(filters.command("ping"))
async def ping(_, m):
    await m.reply_text("ping pong ")

# ----------- LOTTERY COMMANDS -----------

@app.on_message(filters.command("lottery"))
async def cmd_lottery(_, msg):
    await lottery_info(app, msg)


@app.on_message(filters.command("joindaily"))
async def cmd_joindaily(_, msg):
    await join_daily(app, msg)


@app.on_message(filters.command("joinmega"))
async def cmd_joinmega(_, msg):
    await join_mega(app, msg)


@app.on_message(filters.command("listlottery"))
async def cmd_listlottery(_, msg):
    await list_lottery_players(app, msg)

# ----------- LOTTERY CALLBACKS -----------

@app.on_callback_query(filters.regex("^join_daily$"))
async def cb_join_daily(_, cq):
    await join_daily(app, cq.from_user.id, cq.message.reply_text)
    await cq.answer("Daily lottery joined!")


@app.on_callback_query(filters.regex("^join_mega$"))
async def cb_join_mega(_, cq):
    await join_mega(app, cq.from_user.id, cq.message.reply_text)
    await cq.answer("Mega lottery joined!")


#-----------claim-------------
@app.on_message(filters.command("claim") & filters.group)
async def claim(_, msg: Message):

    chat_id = msg.chat.id
    user_id = msg.from_user.id

    # âŒ Already claimed (MongoDB check)
    if await is_group_claimed(chat_id):
        return await msg.reply_text("âŒ This group reward is already claimed!")

    # âœ… Get correct member count
    try:
        chat = await app.get_chat(chat_id)
        members = chat.members_count or 0
    except:
        return await msg.reply_text("âŒ Unable to verify group members")

    if members < 100:
        return await msg.reply_text("âŒ Group must have at least 100 members")

    user = await get_user(user_id)  # âœ… await here

    reward = 10000
    user["bal"] += reward

    # ğŸ’¾ Save user to MongoDB
    await update_user(user_id, user)  # âœ… await here

    # ğŸ”’ Lock group permanently in MongoDB
    await mark_group_claimed(chat_id)  # âœ… await here

    await msg.reply_text(
        f"ğŸ‰ Claim Successful!\n"
        f"ğŸ’° You received â‚¹{reward}\n\n"
        f"ğŸ· Add me to another group to earn more rewards!"
    )

# ---------------- ECONOMY COMMAND ----------------
@app.on_message(filters.command("economy"))
async def economy(_, msg: Message):
    await msg.reply_text(
        ECONOMY_TEXT,
        disable_web_page_preview=True
    )

# ---------- STEP 7 : AUTO AI CHAT ----------

@app.on_message(filters.reply & filters.text)
async def auto_ai(_, msg: Message):

    if msg.text.startswith("/"):
        return

    if not msg.reply_to_message:
        return

    if not msg.reply_to_message.from_user:
        return

    if not msg.reply_to_message.from_user.is_bot:
        return

    # âœ… FIXED LINE
    await msg.reply_chat_action(ChatAction.TYPING)

    reply = groq_reply(msg.text)
    await msg.reply_text(reply)

#--------time-mng-lottery
# Bot start ke thoda pehle

def start_lottery_scheduler():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.run_until_complete(lottery_scheduler(app))

threading.Thread(target=start_lottery_scheduler, daemon=True).start()

print("âœ… Leena Bot Started Successfully")
app.run()
